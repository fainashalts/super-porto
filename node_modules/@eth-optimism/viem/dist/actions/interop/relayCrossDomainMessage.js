import { estimateContractGas, simulateContract } from 'viem/actions';
import { l2ToL2CrossDomainMessengerAbi } from '../../abis.js';
import { contracts } from '../../contracts.js';
import { baseWriteAction, } from '../../core/baseWriteAction.js';
/**
 * Relays a message emitted by the CrossDomainMessenger
 * @category Actions
 * @param client - L2 Client
 * @param parameters - {@link RelayCrossDomainMessageParameters}
 * @returns transaction hash - {@link RelayCrossDomainMessageReturnType}
 * @example
 * import { createPublicClient } from 'viem'
 * import { http } from 'viem/transports'
 * import { op, unichain } from '@eth-optimism/viem/chains'
 *
 * const publicClientOp = createPublicClient({ chain: op, transport: http() })
 * const publicClientUnichain = createPublicClient({ chain: unichain, transport: http() })
 *
 * const receipt = await publicClientOp.getTransactionReceipt({ hash: '0x...' })
 * const messages = await getCrossDomainMessages(publicClientOp, { logs: receipt.logs })
 *
 * const message = messages.filter((message) => message.destination === unichain.id)[0]
 * const params = await buildExecutingMessage(publicClientOp, { log: message.log })
 *
 * const hash = await relayCrossDomainMessage(publicClientUnichain, params)
 */
export async function relayCrossDomainMessage(client, parameters) {
    const { id, payload, ...txParameters } = parameters;
    return baseWriteAction(client, {
        abi: l2ToL2CrossDomainMessengerAbi,
        contractAddress: contracts.l2ToL2CrossDomainMessenger.address,
        contractFunctionName: 'relayMessage',
        contractArgs: [id, payload],
    }, txParameters);
}
/**
 * Estimates gas for {@link relayCrossDomainMessage}
 * @category Actions
 * @param client - L2 Client
 * @param parameters - {@link RelayCrossDomainMessageParameters}
 * @returns estimated gas value.
 */
export async function estimateRelayCrossDomainMessageGas(client, parameters) {
    const { id, payload, ...txParameters } = parameters;
    return estimateContractGas(client, {
        abi: l2ToL2CrossDomainMessengerAbi,
        address: contracts.l2ToL2CrossDomainMessenger.address,
        functionName: 'relayMessage',
        args: [id, payload],
        ...txParameters,
    });
}
/**
 * Simulate contract call for {@link relayCrossDomainMessage}
 * @category Actions
 * @param client - L2 Client
 * @param parameters - {@link RelayCrossDomainMessageParameters}
 * @returns contract return value - {@link RelayCrossDomainMessageContractReturnType}
 */
export async function simulateRelayCrossDomainMessage(client, parameters) {
    const { account, id, payload, accessList } = parameters;
    const res = await simulateContract(client, {
        account,
        abi: l2ToL2CrossDomainMessengerAbi,
        address: contracts.l2ToL2CrossDomainMessenger.address,
        chain: client.chain,
        functionName: 'relayMessage',
        args: [id, payload],
        accessList,
    });
    return res.result;
}
//# sourceMappingURL=relayCrossDomainMessage.js.map