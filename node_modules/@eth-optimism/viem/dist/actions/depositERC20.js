import { BaseError, createPublicClient, http } from 'viem';
import { parseAccount } from 'viem/accounts';
import { estimateContractGas, readContract, simulateContract, } from 'viem/actions';
import { optimismMintableERC20Abi, standardBridgeAbi } from '../abis.js';
import { baseWriteAction } from '../core/baseWriteAction.js';
export class DepositERC20RemoteTokenMismatchError extends BaseError {
    constructor(local, remote) {
        super(`OptimismMintableERC20 remote token address mismatch. Local: ${local}, Remote: ${remote}`);
    }
}
/**
 * Deposit an ERC20 into an OptimismMintableERC20 | OptimismSuperchainERC20.
 * @category Actions
 * @param client - Client for the depositing chain
 * @param parameters - {@link DepositERC20Parameters}
 * @returns The transaction hash. {@link DepositERC20ReturnType}
 * @example
 * import { depositERC20 } from '@eth-optimism/viem'
 * import { op } from '@eth-optimism/viem/chains'
 *
 * const hash = await depositERC20(client, {
 *   tokenAddress: '0x0000000000000000000000000000000000000000',
 *   remoteTokenAddress: '0x0000000000000000000000000000000000000000',
 *   amount: 1000000000000000000n,
 *   targetChain: op,
 * })
 */
export async function depositERC20(client, parameters) {
    const { chain = client.chain, to = parameters.to ?? parseAccount(parameters.account).address, minGasLimit = parameters.minGasLimit ?? 0, extraData = parameters.extraData ?? '0x', tokenAddress: localTokenAddress, remoteTokenAddress, amount, targetChain, unsafe, } = parameters;
    const bridgeAddress = (() => {
        if (parameters.l1StandardBridgeAddress)
            return parameters.l1StandardBridgeAddress;
        if (chain)
            return targetChain.contracts.l1StandardBridge[chain.id].address;
        return Object.values(targetChain.contracts.l1StandardBridge)[0].address;
    })();
    if (!unsafe && targetChain) {
        const remoteClient = parameters.remoteClient ??
            createPublicClient({ chain: targetChain, transport: http() });
        const _localTokenAddress = await readContract(remoteClient, {
            abi: optimismMintableERC20Abi,
            address: remoteTokenAddress,
            functionName: 'remoteToken',
        });
        if (_localTokenAddress !== localTokenAddress) {
            throw new DepositERC20RemoteTokenMismatchError(localTokenAddress, _localTokenAddress);
        }
    }
    return baseWriteAction(client, {
        abi: standardBridgeAbi,
        contractAddress: bridgeAddress,
        contractFunctionName: 'bridgeERC20To',
        contractArgs: [
            localTokenAddress,
            remoteTokenAddress,
            to,
            amount,
            minGasLimit,
            extraData,
        ],
    }, parameters);
}
/**
 * Estimate the gas cost of the {@link depositERC20} action.
 * @category Actions
 * @param client - Client for the depositing chain
 * @param parameters - {@link DepositERC20Parameters}
 * @returns The gas cost
 */
export async function estimateDepositERC20Gas(client, parameters) {
    const { chain = client.chain, to = parameters.to ?? parseAccount(parameters.account).address, minGasLimit = parameters.minGasLimit ?? 0, extraData = parameters.extraData ?? '0x', tokenAddress: localTokenAddress, remoteTokenAddress, amount, targetChain, } = parameters;
    const bridgeAddress = (() => {
        if (parameters.l1StandardBridgeAddress)
            return parameters.l1StandardBridgeAddress;
        if (chain)
            return targetChain.contracts.l1StandardBridge[chain.id].address;
        return Object.values(targetChain.contracts.l1StandardBridge)[0].address;
    })();
    return estimateContractGas(client, {
        abi: standardBridgeAbi,
        address: bridgeAddress,
        functionName: 'bridgeERC20To',
        args: [
            localTokenAddress,
            remoteTokenAddress,
            to,
            amount,
            minGasLimit,
            extraData,
        ],
        ...parameters,
    });
}
/**
 * Simulate the {@link depositERC20} action.
 * @category Actions
 * @param client - Client for the depositing chain
 * @param parameters - {@link DepositERC20Parameters}
 * @returns The contract functions return value. {@link DepositERC20ContractReturnType}
 */
export async function simulateDepositERC20(client, parameters) {
    const { chain = client.chain, to = parameters.to ?? parseAccount(parameters.account).address, minGasLimit = parameters.minGasLimit ?? 0n, extraData = parameters.extraData ?? '0x', tokenAddress: localTokenAddress, remoteTokenAddress, amount, targetChain, } = parameters;
    const bridgeAddress = (() => {
        if (parameters.l1StandardBridgeAddress)
            return parameters.l1StandardBridgeAddress;
        if (chain)
            return targetChain.contracts.l1StandardBridge[chain.id].address;
        return Object.values(targetChain.contracts.l1StandardBridge)[0].address;
    })();
    const { result } = await simulateContract(client, {
        abi: standardBridgeAbi,
        address: bridgeAddress,
        functionName: 'bridgeERC20To',
        args: [
            localTokenAddress,
            remoteTokenAddress,
            to,
            amount,
            minGasLimit,
            extraData,
        ],
        ...parameters,
    });
    return result;
}
//# sourceMappingURL=depositERC20.js.map